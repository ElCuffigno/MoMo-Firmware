#!/usr/bin/env python

import sys
import os.path
import os
import intelhex

sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from pymomo.proteus.project import Project
from pymomo.mib.descriptor import MIBDescriptor
from pymomo.mib.block import MIBBlock
from pymomo.mib.api import MIBAPI
from pymomo.utilities import build
import cmdln
from colorama import Fore, Style
import pyparsing

class MIBTool(cmdln.Cmdln):
	name = 'mibtool'

	@cmdln.option('-o', '--output', action='store',  help='Output .pdsprj file to create (without extension)')
	@cmdln.option('-t', '--template', action='store', help='Template project with a Pic24F16KA101 firmware project defined')
	@cmdln.option('-p', '--proc', action='store', default='pic24', choices=['pic24', 'pic12'], help="Processor type choose from pic24 or pic12")
	def do_proteus(self, subcmd, opts, project):
		"""${cmd_name}: Generate a proteus vsm project for this board file.

		Create a Proteus VSM 8 project file, copying all of the source files in to the project file and setting the parameters appropriately for the project to compile out of the box in VSM.  A template project file is required so that we can copy the appropriate settings into the created project file.  It should be an empty project created by Proteus VSM with the correct processor type and a firmware project created with no files added.  If any files are present they will be overwritten.
		${cmd_usage}
		${cmd_option_list}
		"""

		self.assert_args(opts, ['template', 'output'])

		if not os.path.exists(opts.template):
			self.error("template project %s does not exist" % opts.template)

		if not os.path.isdir(project):
			self.error("You must pass a directory to mibtool proteus <project directory>")

		proj = Project([project], opts.proc, opts.template)
		proj.create(opts.output)

	@cmdln.option('-o', '--output', action='store', default=None, help="Output direcory to place the command_map.asm file in")
	def do_gen(self, subcmd, opts, mibfile):
		"""${cmd_name}: Compile a .mib file into command_map.asm

		Create a command_map.asm file specifying information about this mib application module by compiling the *.mib file passed in.
		${cmd_usage}
		${cmd_option_list}
		"""

		try:
			d = MIBDescriptor(mibfile)
		except pyparsing.ParseException as e:
			self.error(str(e))

		if opts.output is None:
			self.error("You must specify an output directory")
		if not os.path.isdir(opts.output):
			self.error("Invalid output directory specified")

		d.get_block().create_asm(opts.output)

	def do_checksum(self, subcmd, opts, hexfile):
		"""${cmd_name}: Compute an 8-bit checksum for the mib12 application module

		The application module must have a valid mib block so that we can extract
		the hw type in order to properly calculate where to start computing the
		checksum.
		${cmd_usage}
		${cmd_option_list}
		"""

		#Load the chip type from the mib block and use that to extract the application
		#rom range.
		try:
			b = MIBBlock(hexfile)
			info = build.get_proc(b.chip_name)
			start,end = info.app_rom
		except:
			self.error(str(sys.exc_info()[1]))

		ih = intelhex.IntelHex(hexfile)
		ih.padding = 0xFF

		check = 0
		for i in xrange(start, end+1):
			low = ih[i*2]
			high = ih[i*2+1]
			high = high & 0b00111111
			check += low + high
			check &= 0xFF

		check = check & 0xFF

		print "\nChecksum:"
		print "hex: 0x%X" % check
		print "dec: %d" % check
		print "bin: %s" % bin(check)

	def do_dump(self, subcmd, opts, hexfile):
		"""${cmd_name}: Dump the MIB Block from a hex file and verify it.

		Given a hex file that should be a valid MIB12 application module, dump the MIB Block, validate the information stored in it and dump it to stdout.
		${cmd_usage}
		${cmd_option_list}
		"""

		try:
			b = MIBBlock(hexfile)
			print str(b)
		except:
			self.error(str(sys.exc_info()[1]))

	@cmdln.option('-c', '--chip', help="Chip type that this hex file corresponds to")
	def do_api(self, subcmd, opts, hexfile):
		"""${cmd_name}: Dump the MIB API region from the hex file and verify it. 

		Given a hex file that should be a valid MIB12 executive module, validate the information stored in it and dump it to stdout.
		${cmd_usage}
		${cmd_option_list}
		"""

		self.assert_args(opts, ['chip'])

		try:
			print "\nDumping file: %s" % hexfile
			api = MIBAPI(hexfile, opts.chip)
			api.print_api()
		except:
			self.error(str(sys.exc_info()[1]))

	def assert_args(self, opts, args):
		for arg in args:
			if not hasattr(opts, arg) or getattr(opts, arg) is None:
				self.error("You must specify an argument for %s" % arg)

	def error(self, text):
		print Fore.RED + "Error Occurred: " + Style.RESET_ALL + text
		sys.exit(1)

if __name__ == "__main__":
	mibtool = MIBTool()
	sys.exit(mibtool.main())