#!/usr/bin/env python

import sys
import os.path
import os
import intelhex

sys.path.append(os.path.join(os.path.dirname(__file__), '..'))

from pymomo.commander.meta import *
from pymomo.commander.exceptions import *
import cmdln
from colorama import Fore, Style
import pytest

class ModTool(cmdln.Cmdln):
	name = 'modtool'

	@cmdln.option('-p', '--port', help='Serial port that fsu is plugged into')
	def do_list(self, subcmd, opts):
		"""${cmd_name}: List all attached MIB modules on the bus
		
		${cmd_usage}
		${cmd_option_list}
		"""

		con = self._get_controller(opts)
		mods = con.enumerate_modules()

		print "Listing attached modules"
		for i, mod in enumerate(mods):
			print "%d: %s at address %d" % (i, mod.name, mod.address)

	def do_test(self, subcmd, opts, *tests):
		"""${cmd_name}: Run hardware tests on attached MoMo device

		Call with list as the only argument to see all of the different
		tests that are available.  Call with no arguments to run all tests.
		Call with test class names to run only those tests.

		${cmd_usage}
		${cmd_option_list}
		"""

		if len(tests) == 1 and tests[0] == 'list':
			test_string = '--collect-only'
		else:
			test_string = " ".join(map(lambda x: "-k " + x, tests))

		pytest.main('--pyargs pymomo %s' % test_string)

	@cmdln.option('-p', '--port', help='Serial port that fsu is plugged into')
	@cmdln.option('-t', '--type', options=['module', 'controller', 'backup'], default='module', help='What type of firmware module')
	@cmdln.option('-c', '--clear', action='store_true', default=False, help='Clear the firmware cache before pushing')
	def push_firmware(self, subcmd, opts, hexfile):
		"""${cmd_name}: Push a firmware file to the attached momo unit.  

		You can either push the firmware into the 4 module firmware bins,
		the main controller firmware bin or the backup controller firmware
		bin.  Use -c to clear the controller's firmware cache before pushing.

		${cmd_usage}
		${cmd_option_list}
		"""

		con = self._get_controller(opts)

		if opts.clear:
			controller.clear_firmware_cache()

		if opts.type == "module":
			type = 0
			print "Pushing module firmware"
		elif opts.type == "controller":
			type = 4
			print "Pushing main controller firmware"
		elif opts.type == "backup":
			type = 5
			print "Pushing backup controller firmware"

		controller.push_firmware(hexfile, type, verbose=True)

	@cmdln.option('-p', '--port', help='Serial port that fsu is plugged into')
	def do_info(self, subcmd, opts, index):
		"""${cmd_name}: Describe the mib module given its index

		Index is returned by mobtool list
		${cmd_usage}
		${cmd_option_list}
		"""
		
		con = self._get_controller(opts)
		mod = con.describe_module(int(index))

		print "Module at index %d" % int(index)
		print "Name: %s" % mod.name
		print "Address: %d" % mod.address
		print "Features: %d" % mod.num_features

	@cmdln.option('-p', '--port', help='Serial port that fsu is plugged into')
	@cmdln.option('-a', '--address', default=None, help='Select device by address')
	@cmdln.option('-n', '--name', default=None, help='Select device by name')
	def do_reflash(self, subcmd, opts, hexfile):
		"""${cmd_name}: Reflash the mib12 module given either its name or address 

		If name is passed, the first mib module with that name is reflashed.  If
		address is passed, the address must match a currently attached module and
		that module will be reflashed.  You must pass either an address or a name,
		but not both.

		HEXFILE should be a valid mib12 application module.  The controller firmware
		cache will be cleared during the reflashing process and the module in question
		will be reset. 
		
		${cmd_usage}
		${cmd_option_list}
		"""

		con = self._get_controller(opts)
		reflash_module(con, hexfile, name=opts.name, address=int(opts.address))

	def _get_controller(self, opts):
		try:
			c = get_controller(opts.port)
		except ValueError as e:
			self.error(str(e))

		return c

	def error(self, text):
		print Fore.RED + "Error Occurred: " + Style.RESET_ALL + text
		sys.exit(1)


if __name__ == "__main__":
	modtool = ModTool()
	sys.exit(modtool.main())